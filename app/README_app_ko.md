# Crack! 메시지 전송 데모 앱 사용설명서

## 1. 개요

이 애플리케이션은 Crack! 보안 라이브러리(aes.c, crack_aes.c, sha512.c)를 기반으로 한 콘솔형 메시지 전송 데모 앱입니다.

주요 특징은 다음과 같습니다.

하나의 앱에서 사용자가 암호화 프로파일을 선택해 사용

- **AES(속도형)**: 순수 AES-CTR/ECB/CBC 중 선택
- **CRACK_AES(보안형)**: AES-CTR + HKDF-SHA-512 + HMAC-SHA-512 (Encrypt-then-MAC)

두 가지 사용 시나리오 지원:

로컬 테스트 모드 – 한 프로그램 안에서 암·복호화 동작을 실험

서버 / 클라이언트 모드 – 소켓을 이용해 암호화된 채팅 데모(같은 PC 또는 LAN 내 두 PC 간)

---

## 2. 빌드 방법

### 2.1 디렉토리 구조 (예시)

```text
app/
 ├─ aes.c
 ├─ aes.h
 ├─ crack_aes.c
 ├─ crack_aes.h
 ├─ sha512.c
 ├─ sha512.h
 └─ call.c      // 본 데모 앱 메인 파일
```


### 2.2 Windows (MSVC cl) 기준 빌드

call.c 상단에 다음 예시가 주석으로 포함되어 있습니다.

test

cl /utf-8 /std:c17 /O2 /W4 /D_CRT_SECURE_NO_WARNINGS ^
    call.c aes.c crack_aes.c sha512.c ws2_32.lib advapi32.lib


/utf-8 : 콘솔 한글 출력용

/std:c17 : C17 표준

/O2 : 최적화

/W4 : 경고 레벨 상향

ws2_32.lib : Windows 소켓 라이브러리 링크

빌드 후 call.exe 가 생성됩니다.

### 2.3 Linux / macOS (참고용)

macOS에서도 동일한 POSIX 코드 경로를 사용합니다. 기본 clang 컴파일러로 다음과 같이 빌드할 수 있습니다.

clang -O2 -std=c17 call.c aes.c crack_aes.c sha512.c -pthread -o call

-pthread : 스레드 사용

필요에 따라 -Wall -Wextra 등을 추가해 경고를 더 엄격하게 볼 수 있습니다.

## 3. 실행 방법 개요

프로그램을 실행하면 먼저 셀프 테스트를 수행한 뒤, 3가지 모드 중 하나를 선택하는 메뉴가 출력됩니다.

```text
============================================================
       AES 암호화 통신 시스템
============================================================

[SELFTEST] OK

모드를 선택하세요:
  [1] 로컬 테스트 (암호화/복호화)
  [2] 서버 모드 (연결 대기)
  [3] 클라이언트 모드 (서버에 연결)
선택:
```


각 모드는 아래와 같이 사용합니다.

## 4. 모드별 사용법

### 4.1 로컬 테스트 모드

선택 경로:
프로그램 실행 → 모드 선택에서 [1] 로컬 테스트 선택

test

암호화 / 복호화 선택

작업을 선택하세요:
  [1] 암호화 (평문 → 암호문)
  [2] 복호화 (암호문 → 평문)
선택:


[암호화] 선택 시 흐름

평문 입력

평문을 입력하세요 (최대 2047바이트):
> Hello AES!


프로파일 선택 (AES vs CRACK_AES)

사용할 프로파일을 선택하세요:
  [1] AES 속도형 (CTR / ECB / CBC)
  [2] CRACK_AES 보안형 (CTR + HKDF + HMAC-SHA-512)
선택:

=============================================
AES 속도형

- 순수 AES-CTR/ECB/CBC 구현

- 속도와 처리량에 초점을 둔 프로파일
=============================================
CRACK_AES 보안형

- AES-CTR + HKDF-SHA-512 + HMAC-SHA-512 결합

- 키 파생, 무결성 검증(MAC)을 모두 포함한 보안 중심 프로파일
=============================================



**AES 선택 시 – 운용 모드 선택**

[AES] 운용 모드를 선택하세요:
  [1] CTR
  [2] ECB
  [3] CBC
선택:


선택한 값에 따라 내부에서

aes_ctr_encrypt(...)
aes_ecb_encrypt(...)
aes_cbc_encrypt(...)


중 하나를 호출하여 암호화를 수행합니다.


**CRACK_AES 선택 시**

별도 운용 모드 선택 없이 crack_aes_encrypt()가 호출됩니다.

내부적으로

HKDF-SHA-512로 암·복호화 키와 MAC 키를 파생

AES-CTR로 암호화

HMAC-SHA-512로 태그(tag)를 생성 (Encrypt-then-MAC 구조)

[복호화] 선택 시 흐름

프로파일 선택 (AES / CRACK_AES)

AES인 경우 다시 CTR/ECB/CBC 중에서 복호화 모드를 선택

각 모드별로

aes_ctr_decrypt_only();
aes_ecb_decrypt_only();
aes_cbc_decrypt_only();
crack_aes_decrypt_only();


를 호출하여, 이전에 출력된 암호문/nonce/IV/tag 등을 입력받아 평문을 복원합니다.



### 4.2 서버 모드

선택 경로:
프로그램 실행 → 모드 선택에서 [2] 서버 모드 선택

test

포트 번호 설정

포트 번호를 입력하세요 (기본값: 12345):
> 


엔터만 치면 기본 포트 12345 사용

숫자를 입력하면 해당 포트로 대기

서버는 선택한 포트에서 클라이언트 접속을 기다립니다.

클라이언트가 접속하면 **양방향 채팅**이 시작되며, 주고받는 모든 메시지는 **선택된 암호화 모드**로 보호됩니다.

콘솔에서 입력하는 텍스트는 send_encrypted_message()를 통해 암호화되어 전송되고, 상대방으로부터 수신한 데이터는 recv_encrypted_message()를 통해 복호화되어 표시됩니다.




### 4.3 클라이언트 모드

선택 경로:
프로그램 실행 → 모드 선택에서 [3] 클라이언트 모드 선택

test

서버 IP와 포트 입력

서버가 실행 중인 PC의 IP 주소와 포트를 입력합니다.

서버와의 TCP 연결이 성공하면, 서버와 마찬가지로

콘솔 입력 → 암호화 후 전송

소켓 수신 → 복호화 후 표시
형태로 채팅이 진행됩니다.

**TIP**
한 PC에서 테스트하고 싶다면, 서버는 127.0.0.1, 포트는 동일하게 맞추고 두 개의 콘솔을 띄워 각각 서버/클라이언트 모드를 실행하면 됩니다.




## 5. 암호화 프로파일 및 전송 포맷

### 5.1 암호화 방식 선택 메뉴

통신 전에(또는 로컬 테스트 전에) 다음 메뉴를 통해 암호화 프로파일과 (필요 시) 패딩 모드를 선택합니다.

test

========================================
 암호화 방식을 선택하세요
========================================
 [1] AES-CTR (스트림 모드)
 [2] AES-ECB (블록 모드, 패딩 필요)
 [3] AES-CBC (블록 모드, IV + 패딩)
 [4] CRACK_AES (보안형: CTR + HMAC-SHA512)
========================================
선택 (기본값 4):


AES-ECB, AES-CBC를 선택한 경우 패딩 모드를 추가로 선택합니다.

패딩 모드를 선택하세요:
 [1] PKCS#7 (권장)
 [2] ANSI X9.23
선택 (기본값 1):

### 5.2 네트워크 전송 패킷 구조

send_encrypted_message()는 선택된 모드에 따라 패킷을 구성해 전송합니다.

공통:

첫 1바이트: CryptoMode (1~4)

CRACK_AES (보안형) 모드:

mode (1B)

nonce (16B)

tag (32B) – HMAC-SHA-512 (32바이트 트렁케이션 예)

ct_len (4B, little-endian)

ciphertext (ct_len B)

AES-CTR / ECB / CBC 모드:

mode (1B)

nonce 또는 iv (16B) (CTR: nonce, CBC: IV, ECB: 더미 or 생략 없이 동일 포맷 유지)

ct_len (4B)

ciphertext (ct_len B)

수신 측의 recv_encrypted_message()는 첫 바이트의 mode 값으로 프로파일을 판별한 뒤, 동일한 키와 포맷으로 복호화를 수행합니다.



## 6. 주요 내부 함수 (개발자 참고용)

앱 사용설명서이지만, 추후 확장을 위해 내부 주요 함수들의 역할을 간단히 정리합니다.

- **run_local_test()**  
  콘솔에서 평문을 입력받고, 프로파일/운용 모드를 고른 뒤 암·복호화를 시험해 보는 로컬 테스트 메뉴입니다.

- **select_crypto_mode()**  
  AES/CRACK_AES, CTR/ECB/CBC, 패딩 방식 등을 선택하는 메뉴를 출력하고  
  선택 결과를 전역 설정 값으로 저장합니다.

- **send_encrypted_message(...)**  
  현재 선택된 암호화 모드에 맞추어 패킷 형식을 결정하고,  
  평문을 암호화한 뒤 네트워크로 전송하는 역할을 합니다.

- **recv_encrypted_message(...)**  
  수신된 패킷에서 모드, nonce/IV, 태그, 암호문을 파싱하고  
  해당 모드에 맞는 API로 복호화·무결성 검증을 수행합니다.

- **run_server(...), run_client(...)**  
  서버/클라이언트 소켓을 생성하고,  
  send/recv 함수를 반복 호출하여 양방향 암호화 채팅을 구성하는 상위 제어 루틴입니다.


## 7. 제한 사항 및 주의점

현재 키(g_comm_key)와 nonce/IV는 데모용 고정값입니다. 실제 서비스에서는 반드시 랜덤 키와 적절한 키 관리가 필요합니다.


CRACK_AES 모드에서 **태그 검증 실패(AES_ERR_AUTH)**가 발생하면, 메시지가 변조되었거나 키/nonce가 다른 경우이므로 해당 메시지를 절대 사용하면 안 됩니다.

본 애플리케이션은 교육용/데모용이며, 실서비스에 바로 적용하기 전에는 키 관리, 인증, 세션 관리, 사용자 인증 등 추가적인 보안 요소가 필요합니다.
